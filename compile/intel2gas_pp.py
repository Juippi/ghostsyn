#!/usr/bin/python3

import fileinput
import struct
import sys
import re
import json
import sys


def str2int(s):
    """ Try to parse integer as either base 10 or 16"""
    try:
        return int(s)
    except ValueError:
        return int(s, 16)

def evaluate(s, defs):
    return eval(s, dict(defs))

if __name__ == "__main__":
    full_proc = False

    if sys.argv[1] == "--full":
        # Do full processing for intro build. Otherwise
        # don't do steps that would break compatibility with C test prog.
        full_proc = True
        args = sys.argv[2:]
    else:
        args = sys.argv[1:]
        
    mode = args[0]
    if mode == "post":
        with open(args[1], "r") as defcache:
            definitions = json.loads(defcache.read())
    else:
        definitions = {}
    
    for line in sys.stdin.readlines():
        fields = line.strip().split()

        # strip trailing comments
        try:
            comment_start = fields.index(";")
            fields = fields[:comment_start]
        except ValueError:
            pass
        
        if not fields:
            continue

        if mode == "defs":
            if len(fields) >= 3 and fields[0] == "%define":
                # print("capture define " + fields[1])
                val = evaluate(" ".join(fields[2:]), definitions)
                definitions[fields[1]] = val

        elif mode == "pre":
            # Transform float constants to bytes, because converter has trouble.
            if len(fields) >= 2 and fields[0] == "dd" and "." in fields[1]:
                val = struct.pack("<f", float(fields[1]))

                # truncate floating point constants here (least significant byte to 0)
                print("db 0x00")
                for b in val[1:]:
                    print("db 0x%.2x" % b)

            # Precompute arithmetic expressions in constant definitions
            elif len(fields) >= 3 and fields[0] == "%define":
                if fields[2].startswith("("):
                    val = evaluate(" ".join(fields[2:]), definitions)
                else:
                    val = str2int(fields[2])
                definitions[fields[1]] = val

            # Drop "%line" generated by nasm pp
            elif fields[0] == "%line":
                continue

            # evaluata data values in case they're expressions
            elif fields[0] in ("db", "dw", "dd", "resb", "resw", "resd"):
                print("%s %d" % (fields[0], eval(" ".join(fields[1:]))))

            # reverse some nasm pp things
            elif fields[0] == "[section":
                print("section " + fields[1][:-1])

            elif fields[0] == "[global":
                print("global %s" % fields[1][:-1])

            else:
                print(line.strip())

        elif mode == "post":

            if full_proc:
                # # transform addresses referring to bss to (g_buffer + <constant>)
                if len(fields) > 1:
                    operands = " ".join(fields[1:]).split(",")
                    for p in range(len(operands)):
                        if re.match("^bss_.*", operands[p]):
                            operands[p] = "_ZL14g_audio_buffer+" + str(definitions["BOFF_" + operands[p][4:].upper()])
                    fields = [fields[0] , ",".join(operands)]

                # remove bss_*: labels, everything is relative to g_buffer now
                if re.match("^bss_.*:", fields[0]):
                    continue

                # remove .bss, not needed in intro
                if re.match("^.bss", fields[0]):
                    continue

                # remove g_buffer:
                if re.match("^g_buffer:", fields[0]):
                    continue

                # remove .space
                if re.match("^[.]space", fields[0]):
                    continue

                # remove .global
                if re.match("^[.]global.*", fields[0]):
                    continue

            # Fix invalid fld1 instructions
            if fields == ["fld", "$1"]:
                print("fld1")

            # Fix invalid fxch instructions
            elif len(fields) >= 2 and fields[0] == "fxch":
                print("fxch %s" % fields[1].split(",")[0])

            # Fix shift with wrong operand size
            elif fields == ["shlb",  "%cl,%ebx"]:
                print("shl %cl,%ebx")

            # fix fpu instruction memory operand sizes
            elif fields[0] not in  ("fmul", "fildl", "fistpl", "fidivl", "fimull") and fields[0][0] == "f" and fields[0][-1] == "l":
                print("%ss %s" % (fields[0][:-1], " ".join(fields[1:])))

            # fix section starts
            elif fields[0].split(".")[-1] in ("data:", "text:", "bss:"):
                print(".%s" % fields[0].split(".")[-1][:-1])

            # fix incorrect fsubp instructions
            elif fields[0] == "fsubp":
                print("fsubrp %s" % " ".join(fields[1:]))

            # fix incorrect fdivp instructions
            elif fields[0] == "fdivp":
                print("fdivrp %s" % " ".join(fields[1:]))

            else:
                print(" ".join(fields))

        else:
            assert False, "unrecognized mode %s" % mode

    if mode == "defs":
        with open(args[1], "w") as defcache:
            defcache.write(json.dumps(definitions))  # needed again in PP step
